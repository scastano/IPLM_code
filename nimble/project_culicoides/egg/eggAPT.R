#################################################################################################
## Supplementary material to "Lefkovitch matrices meet integral projection models: quantifying ##
## the effects of individual heterogeneity in hidden developmental processes"                  ##
#################################################################################################

####################################################
## IPLM model and MCMC for stage=EGG              ## 
## Sampler: adaptive parallel tempering algorithm ##
####################################################

rm(list=ls())

## Set basic parameters
options(width=500)
## libraries
library(latex2exp)
library(nimble)
library(coda)

## Flag to toggle plotting output
PDF <- FALSE ## TRUE

baseDir <- "~/IPLM_paper/nimble/project_culicoides/egg"
setwd(baseDir)
nimPrint("Directory is: ", baseDir)


## ###########################################
## Take arguments from script, if available ##
CA <- commandArgs(TRUE)
if (length(CA)==0) {
    UseScript <- FALSE
} else {
    UseScript <- TRUE
}

if (UseScript) { 
    print(CA)
    print(iRES   <- as.integer(CA)[1])
    print(qsubID <- as.integer(CA)[2])
} else {
    qsubID <- 123456789
}


## ###########################################
## Source scripts to initialise the process ##
setwd(baseDir)
source("../../FUNCTIONS_R.R")
source("../../FUNCTIONS_NIMBLE.R")
source("../FUNCTIONS_CULICOIDES.R")
source("../../RW_APT/APT_build.R")
source("eggDataConstantsInitial.R")

###################################################################################
## BUGS code for integral projection Lefkovitch matrix (IPLM) model for egg data ##
CodeEgg <- nimbleCode ({
    ## KERNEL PARAMETERS AND TRAVELLING WAVE
    for (tt in 1:nTempsE) {
        logit(paras[tt,1]) ~ dLogitUnif() ## Expected value
        logit(paras[tt,2]) ~ dLogitUnif() ## Scale
        logit(paras[tt,3]) ~ dLogitUnif() ## Survival
        ## TRAVELLING WAVE
        muSigSurv[tt,1:3] <- nf_TW1_MuSigSurv(paras = paras[tt,1:3], res = resE, thresh = thresh)
        ## REPARAMETERISATION
        alphas[tt,1:2]    <- nf_muVar2alpha(nf_muSc2muVar(paras[tt,1:2]))
        P01[tt]           <- qbeta(0.01, alphas[tt,1], alphas[tt,2])
        P99[tt]           <- qbeta(0.99, alphas[tt,1], alphas[tt,2])
    }
    ## LIKELIHOOD: VAUGHAN DATA
    VaughanSSPre[1:nTempsVaughan] ~ dmultinom(size=VaughanTSSPre, prob=pVaughanSSpre[1:nTempsVaughan]) 
    for (ii in 1:nTempsVaughan) {
        ## SURVIVAL
        VaughanSSPost[ii]  <- myRound(VaughanSSPre[ii] * VaughanSurvObs[ii], 0) ## Expected value of post-experimentation sample-size given imputed pre-experimentation sample-size and the observed proportion that survived
        VaughanSurvInd[ii] ~ dPseudoBeta(VaughanSSPre[ii], VaughanSSPost[ii], muSigSurv[VaughanRowToTempsIndex[ii],3]) ## The likelihood of the estimated survival probability given the pre- and post-experimentation sample sizes
        ## DEVELOPMENT
        VaughanMuSig[ii,1:2] ~ dObMuSig(mu  = muSigSurv[VaughanRowToTempsIndex[ii],1], ## Likelihood of the reported mean and standard deviation given those generated by the travelling wave
                                        sig = muSigSurv[VaughanRowToTempsIndex[ii],2],
                                        N   = VaughanSSPost[ii])
    }
    ## LIKELIHOOD: MULLENS DATA
    MullensSSPost[1:nTempsMullens] ~ dmultinom(size=MullensTSSPost, prob=pSSPostMullens[1:nTempsMullens]) 
    for (ii in 1:nTempsMullens) {
        MullensMuSig[ii,1:2] ~ dObMuSig(mu  = muSigSurv[MullensRowToTempsIndex[ii],1],
                                        sig = muSigSurv[MullensRowToTempsIndex[ii],2],
                                        N   = MullensSSPost[ii])
    } 
    ## LIKELIHOOD: INSECTARIUM DATA
    pDevDead[1:nStepsInsectarium, 1:2] <- travellingWave_paras2pDevDead(paras = paras[InsectariumToTempsIndex, 1:3], res = resE, nIter = nStepsInsectarium) 
    for (i in 1:nGroupsInsectarium) {
        InsectariumEgg15[i,1:nStepsInsectarium] ~ dMaturation(sSize = sampSizesInsectariumEgg15[i], pDev = pDevDead[1:nStepsInsectarium, 1]) 
    }
    ## SHAPE CONSTRAINTS
    constraintData ~ dconstraint(1 == (1 < min(alphas[1:nTempsE, 1:2])) *
                                      dUnimodal(paras[1:nTempsE, 1])    * 
                                      dUnimodal(paras[1:nTempsE, 3])    * 
                                      dUnimodal(P01[1:nTempsE])         * 
                                      dUnimodal(P99[1:nTempsE]))
})

## ASSEMBLE NIMBLE MODEL
EggModel <- nimbleModel(CodeEgg, constants=Constants, inits=Inits, data=Data, check=TRUE)

###################
## EXAMINE MODEL ##
EggModel$getNodeNames()
EggModel$logit_paras
EggModel$paras
EggModel$getDependencies(c('logit_paras'))
EggModel$getDependencies(c('resE'))

#################################################
## Ensure deterministic nodes are up to date   ##
## Update log-likelihood of all dependent data ##
EggModel$getLogProb(EggModel$getDependencies("paras"))  ## If there are NAs it can be because some nodes are not initialised
EggModel$simulate(EggModel$getDependencies("paras"))    ## Ensure deterministic nodes are up to date
EggModel$calculate(EggModel$getDependencies("paras"))   ## Update log-likelihood of all dependent data


## ####################################################
## SET resE from shell script input here & calculate ## 
if (UseScript) 
    EggModel$resE <- iRES

print(EggModel$calculate())
resE <- EggModel$resE
nimPrint("resE=", EggModel$resE[1])

## Once resE is fixed at the desired value, initialise the output files
source("initialise_output.R")
nimPrint("Working directory is", getwd())

#################################################
## COMPILE MODEL (required for compiling MCMC) ##
cEggModel <- compileNimble(EggModel)

## ####################################################
## Check all logProb monitors are included in output ##
## The following lines should give the same output   ## 
sum(EggModel$logProb_logit_paras,
    EggModel$logProb_VaughanSSPre,
    EggModel$logProb_VaughanSurvInd,
    EggModel$logProb_VaughanMuSig,
    EggModel$logProb_MullensSSPost,
    EggModel$logProb_MullensMuSig,
    EggModel$logProb_InsectariumEgg15)
EggModel$calculate() 


## ############################################################
## CONFIGURE MCMC - WE USE ADAPTIVE PARALLEL TEMPERING (APT) ##

## Create mcmcConf object with no sampler assignment
mcmcConfEgg <- configureMCMC(EggModel, nodes=NULL, control=list(temperPriors=FALSE))
## Monitors
mcmcConfEgg$getMonitors()
mcmcConfEgg$resetMonitors()
mcmcConfEgg$addMonitors(c('resE', 'paras', 'VaughanSSPre', 'MullensSSPost', 'P01', 'P99'))
mcmcConfEgg$addMonitors2(c('logProb_logit_paras','logProb_VaughanSSPre', 'logProb_VaughanSurvInd', 'logProb_VaughanMuSig',
                           'logProb_MullensSSPost', 'logProb_MullensMuSig', 'logProb_InsectariumEgg15')) 


## Add samplers 
mcmcConfEgg$addSampler(target='VaughanSSPre',  type='sampler_RW_multinomial_tempered', control=list(useTempering=FALSE)) 
mcmcConfEgg$addSampler(target='MullensSSPost', type='sampler_RW_multinomial_tempered', control=list(useTempering=FALSE)) 

## Round 1: Blocks of 2
mcmcConfEgg$addSampler(target=c("logit_paras[1,1:2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[2,1:2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[3,1:2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[4,1:2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[5,1:2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[6,1:2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[7,1:2]"), type='sampler_RW_block_tempered')

## Round 1: Blocks of 2
mcmcConfEgg$addSampler(target=c("logit_paras[1:2,1]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[2:3,1]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[3:4,1]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[4:5,1]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[5:6,1]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[6:7,1]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[1:2,2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[2:3,2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[3:4,2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[4:5,2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[5:6,2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[6:7,2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[1:2,3]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[2:3,3]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[3:4,3]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[4:5,3]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[5:6,3]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[6:7,3]"), type='sampler_RW_block_tempered')

## Round 1: Blocks of 3
mcmcConfEgg$addSampler(target=c("logit_paras[1:3,1]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[2:4,1]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[3:5,1]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[4:6,1]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[5:7,1]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[1:3,2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[2:4,2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[3:5,2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[4:6,2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[5:7,2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[1:3,3]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[2:4,3]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[3:5,3]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[4:6,3]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[5:7,3]"), type='sampler_RW_block_tempered')

## Round 1: Blocks of 4
mcmcConfEgg$addSampler(target=c("logit_paras[1:2,1:2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[2:3,1:2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[3:4,1:2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[4:5,1:2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[5:6,1:2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[6:7,1:2]"), type='sampler_RW_block_tempered')

mcmcConfEgg$addSampler(target=c("logit_paras[3,1:2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[4,1:2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[5,1:2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[4:5,1:2]"), type='sampler_RW_block_tempered')

mcmcConfEgg$addSampler(target=c("logit_paras[1,1:2]", "logit_paras[3,1:2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[1:3,1:2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target=c("logit_paras[3,1:2]", "logit_paras[5,1:2]"), type='sampler_RW_block_tempered')
mcmcConfEgg$addSampler(target="logit_paras[3,1]", type='sampler_RW_tempered')

mcmcConfEgg$printSamplers()

#########################
## BUILD & COMPILE APT ##
nTemps   <- 13
mcmcEgg  <- buildAPT(mcmcConfEgg, Temps=exp(seq(0, log(nTemps*10), l=nTemps)), monitorTmax=TRUE, ULT=1E6)
cMcmcEgg <- compileNimble(mcmcEgg, project=EggModel) 

#############################
## MCMC - ADAPTIVE BURN-IN ##
print("#########################")
print("Starting adaptive burn-in")
print("#########################")

THIN           <- 1
cMcmcEgg$thin  <- THIN
cMcmcEgg$thin2 <- THIN
TuneTemper     <- c(1, 1)
meanL          <- cEggModel$calculate() 
meanL_previous <- -Inf
ii             <- 0

while(meanL > meanL_previous + 2) {
    ii <- ii+1
    meanL_previous <- meanL
    print(paste0("iteration nb.", ii, "within while loop. meanL = ", meanL_previous))
    #################
    ## Short run 1 ##
    nIter <- 1E4; cMcmcEgg$thinPrintTemps <- nIter / 10
    syst1 <- system.time(cMcmcEgg$run(nIter,
                                      reset          = TRUE,  ## Resets the adaptive MCMC. Let's proposal distributions change direction if required.
                                      adaptTemps     = FALSE, ## Prevents temperature ladder adaptation (to avoid volatile behaviour when counter is reset)
                                      resetTempering = TRUE,  ## Resets counter used in temperature ladder adaptation
                                      printTemps     = TRUE,  ## Will print once only
                                      tuneTemper1=TuneTemper[1], tuneTemper2=TuneTemper[2]))
    ## Update meanL
    nimPrint("While loop: 1st short run finished. sysT = ", syst1[3])
    samples2 <- tail(as.matrix(cMcmcEgg$mvSamples2), floor(nIter/THIN)) ## LogProbs 
    meanL    <- mean(rowSums(samples2))
    nimPrint("meanL = ", meanL)
    #################
    ## Short run 2 ##
    nIter <- 1E4; cMcmcEgg$thinPrintTemps <- round(nIter / 10) ## Ensures temps are only printed 10 times
    syst2 <- system.time(cMcmcEgg$run(nIter,
                                      reset          = FALSE, ## Do not reset the adaptive MCMC, let adaptation continue as it is
                                      adaptTemps     = TRUE,  ## Allows temperature ladder to adjust 
                                      resetTempering = FALSE, ## Keeps the adjustments modest so avoids volatile behaviour
                                      printTemps     = TRUE,  ## Prevents verbose printing of temperature ladder updates
                                      tuneTemper1=TuneTemper[1], tuneTemper2=TuneTemper[2]))
    nimPrint("While loop: 2nd short run finished. sysT = ", syst2[3])
    ## Update meanL
    samples2 <- tail(as.matrix(cMcmcEgg$mvSamples2), floor(nIter/THIN)) ## LogProbs 
    meanL    <- mean(rowSums(samples2))
    ## Calculate & print ESS 
    samples   <- tail(as.matrix(cMcmcEgg$mvSamples),  floor(nIter/THIN))
    parasCols <- substring(colnames(samples),1,5)=="paras"
    sub       <- samples[,parasCols]
    mc        <- as.mcmc(sub)
    ESS       <- effectiveSize(mc) 
    (ESS      <- ESS[order(ESS)])
    nimPrint(ESS)     
}
print(paste0("iteration nb.", ii, "within while loop. meanL = ", meanL))

print("accCountSwap")
print(cMcmcEgg$accCountSwap)


## ######################################################################
## Extract MCMC samples & LogProbs from last round of adaptive burn-in ##
samples     <- tail(as.matrix(cMcmcEgg$mvSamples),     floor(nIter/THIN)) ## Sampled parameters T=1
samplesTMax <- tail(as.matrix(cMcmcEgg$mvSamplesTmax), floor(nIter/THIN)) ## Sampled parameters T=Tmax
samples2    <- tail(as.matrix(cMcmcEgg$mvSamples2),    floor(nIter/THIN)) ## LogProbs
print("Finished extracting model values samples & samples2")

## Check dimensions match
if( dim(samples)[1] != dim(samples2)[1])
    stop("nrow of samples & samples2 don't match")
print("DIMENSION OF samples & samples2 are OK")

## Optionally, Plot Temperature Trajectories
if (PDF) {
    print("start plotting first PDF")
    pdf(file=paste0("egg_APT_temperature_trajectory_", nTemps, ".pdf"))
    par(mfrow=n2mfrow(1))
    tt     <- cMcmcEgg$tempTraj 
    myCols <- rainbow(nTemps)
    sub    <- 1:nrow(tt)
    plot(sub, tt[sub,1], ylim=range(tail(tt, ceiling(4/5*nrow(tt)))),
         typ="l", col=myCols[1], xlab="nb. iterations", ylab="Temperatures ", main="APT - Temperature trajectories")
    for (i in 2:ncol(tt)) lines(sub, tt[sub,i], col=myCols[i])
    dev.off()
}
print("Finished  plotting first  PDF")

## Optionally Examine trajectories of parameters
if (PDF) {
    mc <- as.mcmc(tail(samples, nIter/THIN))
    pdf(file=paste0("egg_APT_paras-trajectories_nTemps", nTemps, ".pdf"))
    plot(mc)
    dev.off()
}

if(PDF) {
    mcTMax <- as.mcmc(tail(samplesTMax, nIter/THIN))
    pdf(file=paste0("egg_APT_paras-trajectories_TMAX_nTemps", nTemps, ".pdf"))
    plot(mcTMax)
    dev.off()
}
print("Finished last PDFs")

## ###########################################
## ### DIAGNOSTICS - Effective Sample Size ###
## ###########################################
print("starting ESS calculation")

## Filter columns
parasCols <- substring(colnames(samples),1,5)=="paras"
sub       <- samples[,parasCols]
## Check: these should match
matrix(sub[nrow(sub),], nrow=7)
cEggModel$paras
##
mc         <- as.mcmc(sub)      
ESS        <- effectiveSize(mc) 
(ESS       <- ESS[order(ESS)])
iCandidate <- 1  
candidate  <- names(ESS[iCandidate])  ## CANDIDATE FOR NEW BLOCK SAMPLERS (to add to the list of samplers above)
(SuggestedThinning <- round(nIter / ESS[iCandidate]))  
nimPrint("SuggestedThinning is ", SuggestedThinning)

## ############################################################################
## If min(ESS) & SuggestedThinning are terrible at this point...             ##
## perhaps return to sampler declarations and add more samplers              ##
## Alternatively pay attention to what Temps and samplesTMax have been doing ##
## ############################################################################


## #################################
## Some checks and optional plots ##

## These should match
sum(cEggModel$logProb_logit_paras, cEggModel$logProb_VaughanSSPre, cEggModel$logProb_VaughanSurvInd, cEggModel$logProb_VaughanMuSig,
    cEggModel$logProb_MullensSSPost, cEggModel$logProb_MullensMuSig, cEggModel$logProb_InsectariumEgg15)
cEggModel$calculate() 

if(PDF) {
    ## These should match
    mv2 <- tail(as.matrix(cMcmcEgg$mvSamples2), nIter/THIN)
    LP  <- rowSums(mv2)
    tail(LP, 1)
    cEggModel$calculate()
    pdf(file=paste0("egg_APT_LogProb_nTemps", nTemps, ".pdf"))
    plot(LP, typ="l")
    dev.off()
}


##########################
##########################
#### MCMC - INFERENCE ####
##########################
##########################

print("Starting MCMC for inference") 
THIN  <- ceiling(SuggestedThinning * 3) 
nIter <- 1E4 * THIN 
cMcmcEgg$thin  <- cMcmcEgg$thin2 <- THIN
sysT <- system.time(cMcmcEgg$run(nIter,
                                 reset          = FALSE, ## Keeps proposal distributions as they are (initially)
                                 adaptTemps     = FALSE, ## Fix the temperature ladder
                                 resetTempering = FALSE, ## Do not reset the counter for temperature ladder adaptation
                                 printTemps     = TRUE,  ## Do print the temperature ladder once
                                 tuneTemper1=TuneTemper[1], tuneTemper2=TuneTemper[2]))
nimPrint("MCMC finished. sysT = ", sysT[3])


## Get samples & some info to store in output
samples     <- tail(as.matrix(cMcmcEgg$mvSamples),     floor(nIter/THIN)) ## Sampled parameters
samples2    <- tail(as.matrix(cMcmcEgg$mvSamples2),    floor(nIter/THIN)) ## LogProbs
samplesTMax <- tail(as.matrix(cMcmcEgg$mvSamplesTmax), floor(nIter/THIN)) ## Sampled parameters T=Tmax
parasCols   <- substring(colnames(samples),1,5)=="paras" ## filter columns
sub         <- samples[,parasCols]
mc          <- as.mcmc(sub)
ESS         <- effectiveSize(mc)
nimPrint(ESS)

## Dimension check
if( dim(samples)[1] != dim(samples2)[1])
    stop("nrow of samples & samples2 don't match")
print("DIMENSION OF samples & samples2 are OK")

## To avoid csv file having colnames such as "MullensSSPost.1." "paras.2..1." etc, rename columns here
colnames(samples) <- c(paste0("MullensSSPost",temps[MullensRowToTempsIndex]),
                       paste("P01", temps, sep='_'),
                       paste("P99", temps, sep='_'),
                       paste0("VaughanSSPre",temps[VaughanRowToTempsIndex]),
                       paste0("mu",  temps),
                       paste0("sc",  temps),
                       paste0("surv",temps),
                       "resE")
colnames(samplesTMax) <- colnames(samples)


## ###########################################
## Set output directory & Save MCMC samples ##
setwd(mcmcDir)
nimPrint("Current working directory is: ", getwd())
nimPrint("MCMC output going to file: ", mcmcFile)
nimPrint("LogProb output going to file: ", mcmcFile2)
nimPrint("TMax MCMC output going to file: ", mcmcFile3)

print("START WRITING SAMPLES")
write.table(samples,     file=mcmcFile,   col.names=TRUE, row.names = FALSE, sep=",")
write.table(samples2,    file=mcmcFile2,  col.names=TRUE, row.names = FALSE, sep=",")
write.table(samplesTMax, file=mcmcFile3,  col.names=TRUE, row.names = FALSE, sep=",")

print("Finished writing samples to file")


##########################
## Save MCMC parameters ##
write(paste("iterations  =", nIter),          file = parametersFile, append = FALSE)
write(paste("thin        =", cMcmcEgg$thin),  file = parametersFile, append = TRUE)
write(paste("thin2       =", cMcmcEgg$thin2), file = parametersFile, append = TRUE)
write(paste("nb. samples =", nrow(samples)),  file = parametersFile, append = TRUE)
write(paste("minimum ESS =", floor(min(ESS))),file = parametersFile, append = TRUE)
##
## Add sampler info
##
sink("mcmc_parameters.txt", append=TRUE)
cat("\n")
STOP <- FALSE
ii   <- 0
while (!STOP) {
    ii  <- ii + 1
    TXT <- try(mcmcConfEgg$printSamplers(ii))
    if (class(TXT) == "try-error") 
        STOP <- TRUE
    else 
        cat(TXT)    
}
cat("\n")
ESS
sink()


print("%%%%%%% FINISHED %%%%%%%%")

